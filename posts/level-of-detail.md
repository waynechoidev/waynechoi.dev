---
title: "Level of detail"
date: "March 10, 2024"
category: "graphics"
tags: ["opengl", "levelofdetail", "tessellation", "mipmap"]
excerpt: "Various Approaches to Implementing LOD(level of detail) in OpenGL..."
---

Level of Detail (LOD) is a crucial concept in computer graphics and game development, utilized to optimize rendering performance while maintaining visual fidelity. LOD techniques dynamically adjust the complexity of objects based on factors such as viewer distance, screen size, or importance within the scene. I implemented several LOD techniques directly using OpenGL.

---

## Tesselation Shader

Tessellation involves automatically subdividing an object's surface to add or reduce detail. To implement LOD using tessellation shaders, it's primarily divided into two stages: the control shader and the evaluation shader. Let's discuss these two shaders.

### Control Shader

The control shader takes vertex data of the object as input. It determines the tessellation level based on LOD and generates new vertices to be passed to the tessellation shader. It dynamically sets the tessellation level to adjust the geometry detail of the object according to LOD.

```cpp
#version 420 core

layout (vertices = 3) out;

void main() {
    int scale = // set the detail level

    gl_TessLevelOuter[0] = scale; // left for quads
    gl_TessLevelOuter[1] = scale; // bot for quads
    gl_TessLevelOuter[2] = scale; // right for quads
    gl_TessLevelOuter[3] = scale; // top for quads

    gl_TessLevelInner[0] = scale; // top bot for quads
    gl_TessLevelInner[1] = scale; // left right for quads
}
```

### Evaluation Shader

The evaluation shader takes as input the new vertices generated by the control shader. It evaluates the surface of the tessellated object and renders the new vertices. It ensures that the tessellated object's geometry detail is appropriately adjusted for rendering.

```cpp
#version 420 core

layout(triangles, equal_spacing, cw) in;

void main() {
  gl_Position = gl_TessCoord.x * gl_in[0].gl_Position +
                gl_TessCoord.y * gl_in[1].gl_Position +
                gl_TessCoord.z * gl_in[2].gl_Position;
}
```

When implementing LOD using tessellation shaders, you typically write these two shaders. The control shader determines the tessellation level based on LOD and generates new vertices to be passed to the evaluation shader. This allows for dynamically adjusting the geometry detail of objects using tessellation shaders.

Additionally, it's crucial to render primitives as patches when using tessellation. I overlooked this detail and spent a lot of time troubleshooting errors.

You can see LOD using tessellation in action in the video below. LOD has been exaggerated for explanatory purposes, but it's not typically this extreme in actual products.

<iframe width="560" height="315" src="https://www.youtube.com/embed/xeJxZ5evPsE?si=2SXREbfjzSR3mU7y" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

## Mesh swap

Using mesh swap for LOD implementation involves preparing separate meshes for each LOD level in advance and dynamically replacing the mesh with the appropriate LOD level based on distance or visibility. This method is primarily handled by the CPU and offers the advantage of reducing GPU load.

Specifically, different meshes must be prepared in advance for each LOD level. For example, prepare meshes with varying levels of detail such as LOD1, LOD2, LOD3, and so on. These pre-prepared meshes are then dynamically swapped out for the appropriate LOD level based on distance.

The implementation steps are as follows:

1. Prepare meshes for multiple levels of LOD, such as LOD1, LOD2, LOD3, etc.
2. Measure the distance between the camera and the object, and determine the appropriate LOD level based on this distance.
3. Render the object using the selected mesh corresponding to the determined LOD level.
4. Update the LOD level and swap the mesh whenever the distance or visibility changes.

Below is a brief example implementing mesh swap for LOD. I've omitted irrelevant parts for brevity.

```cpp
int main()
{
	Window mainWindow = Window(1920, 1080);
	mainWindow.initialise();

	Sphere sphere_1 = Sphere(1.0f, 30, 30);
	sphere_1.initialise();

	Sphere sphere_2 = Sphere(1.0f, 20, 20);
	sphere_2.initialise();

	Sphere sphere_3 = Sphere(1.0f, 10, 10);
	sphere_3.initialise();

	Sphere sphere_4 = Sphere(1.0f, 5, 5);
	sphere_4.initialise();

	// Model
	glm::vec3 translation = glm::vec3(0.0f);
	glm::vec3 scaling = glm::vec3(0.7f);
	glm::vec3 rotation = {0.4f, 2.5f, 0.0f};

    ...

	while (!mainWindow.getShouldClose())
	{

	...

		if (translation.z > -1)
			sphere_1.draw();
		else if (translation.z > -2)
			sphere_2.draw();
		else if (translation.z > -3)
			sphere_3.draw();
		else
			sphere_4.draw();

    ...

	}

	return 0;
}
```

Using this method, CPU manages LOD and swaps meshes, thereby reducing GPU load. However, it requires preparing various LOD meshes in advance and additional management logic for LOD transitions. A downside is the increase in memory usage. Most commercial game engines like Unreal Engine and Unity implement LOD using this approach.

You can observe LOD with mesh swap in action in the video below. LOD has been exaggerated for explanatory purposes, but it's not typically this extreme in actual products.

<iframe width="560" height="315" src="https://www.youtube.com/embed/NaoF8sa1Udg?si=qobD_5N9z6jnL-bJ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

## Mipmap

In most cases, LOD is used to adjust the level of geometric detail. However, the LOD concept is also utilized in texture mapping, known as mipmapping, to enhance rendering quality by adjusting the texture resolution.

LOD using mipmaps involves applying different resolutions of textures to reduce detail for objects that are far away. This is primarily used to improve performance by reducing the detail of textures that are distant.

Specifically, mipmaps involve pre-generating and storing various resolution versions of textures. Multiple resolutions of textures, higher than the original resolution, are prepared. These prepared mipmaps are utilized during texture mapping. When an object is far away, the texture's resolution applied to that object is switched to a lower resolution version from the mipmap.

Mipmaps typically provide a functionality where various resolution versions of textures are automatically generated by the graphics API, rather than being prepared manually by developers. Therefore, developers only need to consider mipmaps during texture creation. Below is the texture creation method that I used when implementing mipmaps.

```cpp
void Texture::initialise(std::string fileLoc)
{
	unsigned char *texData = stbi_load(fileLoc.c_str(), &_width, &_height, &_bitDepth, 0);

	glGenTextures(1, &_textureID);
	glBindTexture(GL_TEXTURE_2D, _textureID);

	// Set texture parameters and generate mipmaps
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// Load texture data and generate mipmaps
	if (_bitDepth == 3)
	{
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, _width, _height, 0, GL_RGB, GL_UNSIGNED_BYTE, texData);
	}
	else if (_bitDepth == 4)
	{
		glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, _width, _height, 0, GL_RGBA, GL_UNSIGNED_BYTE, texData);
	}
	glGenerateMipmap(GL_TEXTURE_2D);

	glBindTexture(GL_TEXTURE_2D, 0);

	stbi_image_free(texData);
}
```

---

The above video demonstrates the simultaneous application of LOD based on geometric level and mipmaps. LOD has been exaggerated for explanatory purposes, but it's not typically this extreme in actual products.

<iframe width="560" height="315" src="https://www.youtube.com/embed/uXcf-MrRKBE?si=Wk-HblygMDMWqNV-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

---

The provided codes have been abstracted or simplified for explanatory purposes. For detailed code and implementation, you can refer to the repository links below

[Repo with tessellation](https://github.com/waynechoidev/level-of-detail-with-tessellation) / [Repo with mesh swap](https://github.com/waynechoidev/level-of-detail-with-mesh-swap)

---

### References

- [Wikipedia - Level of detail](<https://en.wikipedia.org/wiki/Level_of_detail_(computer_graphics)>)
- [UE5 - Creating and Using LODs](https://docs.unrealengine.com/5.3/en-US/creating-and-using-lods-in-unreal-engine/)
- [Unity - Level of Detail (LOD) for meshes](https://docs.unity3d.com/Manual/LevelOfDetail.html)
- [Unity - Importing LOD Meshes](https://docs.unity3d.com/2021.2/Documentation/Manual/importing-lod-meshes.html)
